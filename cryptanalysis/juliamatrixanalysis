# We are looking at eigenvalues and eigenvectors and spectral radii of matrices arising from block ciphers.

using LinearAlgebra
using Random

rng=MersenneTwister(1234);

function map(n,x) list=Vector{Int64}(undef,n); for i in reverse(1:n) if x>2^(i-1) x=x-2^(i-1); list[i]=1; else list[i]=0; end; end; return list; end;

function invmap(list) if length(list)==0 return 1; end;
nn=length(list)-1
mars=[]
for i in 0:nn
push!(mars,2^i)
end;
return 1+dot(list,mars); end;

function shift(list)
n=length(list);
newlist=[];
push!(newlist,list[n]);
if n==0 return newlist; end;
for i in 2:n push!(newlist,list[i-1]) end;
return newlist;
end;

n=6;
function gates(bit,list) list[1]=(bit+list[1]+list[3]+list[4]+list[6])%2; end;


x0=zeros(2^n,2^n);
x1=zeros(2^n,2^n);
expn=2^n;
for i in 1:expn 
list=map(n,i); gates(0,list); x0[i,invmap(shift(list))]=1;
list=map(n,i); gates(1,list); x1[i,invmap(shift(list))]=1;
end;

function makehadamard(n)
zz=[-1 1; 1 1];
for i in 2:n zz=kron(zz,[-1 1; 1 1]) end;
return zz;
end;

xx0=makehadamard(n)*x0*makehadamard(n)/2^n;
xx1=makehadamard(n)*x1*makehadamard(n)/2^n;
yy0=zeros(2^n-1,2^n-1);
yy1=zeros(2^n-1,2^n-1);
for i in 1:2^n-1
for j in 1:2^n-1
yy0[i,j]=xx0[i,j];
yy1[i,j]=xx1[i,j];
end;
end;

function rad(x) return maximum(abs.(eigvals(x))); end;

d=4;

function randmake()
a0=randn(rng, ComplexF32, (d, d));
a1=randn(rng, ComplexF32, (d, d));
return rad(kron(yy0,a0)+kron(yy1,a1))/rad(kron(a0,transpose(adjoint(a0)))+kron(a1,transpose(adjoint(a1))))^(1/2)
end;

a0=randn(rng, ComplexF32, (d, d));
a1=randn(rng, ComplexF32, (d, d));
p=0;

while true
aa0=a0+randn(rng, ComplexF32, (d, d));
aa1=a1+randn(rng, ComplexF32, (d, d));
q=rad(kron(yy0,aa0)+kron(yy1,aa1))/rad(kron(aa0,transpose(adjoint(aa0)))+kron(aa1,transpose(adjoint(aa1))))^(1/2);
if q>=p p=q; display(p); a0=aa0; a1=aa1; end;
end;

d=12; q=12; a0=randn(d,d); a1=randn(d,d); a0=a0/norm(a0); a1=a1/norm(a1); b0=randn(q,q); b1=randn(q,q); hhm=rad(kron(a0,a0)+kron(a1,a1))^(1/2); while true n=30; f(x,y)=rad(kron(x,a0)+kron(y,a1))/rad(kron(x,x)+kron(y,y))^(1/2); old=gradient(f,b0,b1); arm=[]; for k in 1:2 push!(arm,old[k]/f(b0,b1)); end; b0=b0+arm[1]/50; b1=b1+arm[2]/50; display(f(b0,b1)/hhm); b0=b0/norm(b0); b1=b1/norm(b1); end;

function rad(n,x) return norm(x^n)^(1/n); end;

d=30; q=10; a0=randn(d,d); a1=randn(d,d); a0=a0/norm(a0); a1=a1/norm(a1); b0=randn(q,q); b1=randn(q,q); n=30; hhm=rad(n,kron(a0,a0)+kron(a1,a1))^(1/2); while true f(x,y)=rad(n,kron(x,a0)+kron(y,a1))/rad(n,kron(x,x)+kron(y,y))^(1/2); old=gradient(f,b0,b1); arm=[]; for k in 1:2 push!(arm,old[k]/f(b0,b1)); end; b0=b0+arm[1]/3; b1=b1+arm[2]/3; display(f(b0,b1)/hhm); b0=2*b0/(norm(b0)+norm(b1)); b1=2*b1/(norm(b0)+norm(b1)); end;




d=5; n=30; k=10; aa=[]; bb=[]; for i in 1:k push!(aa,randn(n,n)); push!(bb,randn(d,d)); end; function f(mm,x,y) h=size(x[1])[1]*size(y[1])[1]; kk=length(x); amm=zeros(h,h); for i in 1:kk amm=amm+kron(x[i],y[i]); end; return rad(mm,amm); end; m=30; function g(y) return f(m,aa,y)/f(m,y,y)^(1/2); end; aat=[]; while true grad=gradient(g,bb)[1]; bb=(bb+10*grad); bb=0.99*bb+0.01*bb/norm(bb); display(g(bb)); push!(aat,norm(bb[1])/norm(bb[2])); end;


x=[]; for i in 1:7 push!(x,randn(5,5)); end;

function f(x) n=length(x); r=size(x[1])[1]; am=zeros(r,r)^0; bm=zeros(r*r,r*r); for i in 1:n am=am*x[i]; bm=bm+kron(x[i],x[i]); end; return rad(am)^(2/n)/rad(bm); end;

while true x=x+gradient(f,x)[1]/1000; x=0.99*x+0.01*x/norm(x); display(f(x)); end;

