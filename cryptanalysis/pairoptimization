pairfunctor:=function(arm)
local n,m,nn,list,invlist,superarm,i,j,aa;

n:=Length(arm);
m:=Length(arm[1]);
nn:=n*(n-1)/2;

list:=[]; for i in [1..n] do for j in [1..i-1] do Add(list,[i,j]); od; od;
invlist:=[]; for i in [1..n] do invlist[i]:=List([1..n],v->0); od; for i in [1..nn] do invlist[list[i][1]][list[i][2]]:=i; invlist[list[i][2]][list[i][1]]:=i; od;

superarm:=[]; for i in [1..nn] do superarm[i]:=[]; aa:=list[i]; for j in [1..m] do  superarm[i][j]:=invlist[arm[aa[1]][j]][arm[aa[2]][j]]; od; od;

return superarm;
end;

spectralscore:=function(nar,testvalues,pairs)
local list,n,kk,newlist,i,j,m;

list:=StructuralCopy(testvalues);
n:=Length(list);
m:=Length(pairs[1]);
for kk in [1..nar] do
newlist:=[];
for i in [1..n] do
newlist[i]:=0;
for j in [1..m] do 
newlist[i]:=newlist[i]+list[pairs[i][j]];
od;
od;
list:=newlist;
od;
return Sum(List(list,AbsInt)); 
end;

pairscore:=function(nar,testvalues,arm)
return spectralscore(nar,testvalues,pairfunctor(arm));
end;


shift:=function(list) local i,newlist,n; n:=Length(list); newlist:=[]; if n=0 then return newlist; fi; for i in [2..n] do newlist[i]:=list[i-1]; od; newlist[1]:=list[n]; return newlist; end;

map:=function(n,x) local i,list; list:=[]; for i in Reversed([1..n]) do if x>2^(i-1) then x:=x-2^(i-1); list[i]:=1; else list[i]:=0; fi; od; return list; end;

invmap:=function(list) if Length(list)=0 then return 1; fi;
return 1+list*List([0..Length(list)-1],v->2^v); end;

onemodulo:=function(x,y) return RemInt(x-1,y)+1; end;


marksplit:=function(list) local n,output,i,j; n:=LogInt(Length(list),2); output:=[]; for i in [1..n] do output[i]:=[]; for j in [1..2^(i-1)] do output[i][j]:=Remove(list); od; od; return Reversed(output); end;

bitstopairs:=function(oldlist)
local list,n,logn,pairs,i,mapi,j,mar,k;

n:=Length(oldlist);
logn:=LogInt(n,2);
list:=marksplit(StructuralCopy(oldlist));

pairs:=[];
for i in [1..n] do
pairs[i]:=[];

mapi:=shift(map(logn,i));

for j in [1..logn] do
mar:=[];
for k in [j+1..logn] do
Add(mar,mapi[k]);
od;
mapi[j]:=RemInt(mapi[j]+list[j][invmap(mar)],2);
od;
pairs[i][1]:=invmap(mapi);
mapi[1]:=1-mapi[1];
pairs[i][2]:=invmap(mapi);
od;

return pairs;
end;

nn:=128;

population:=List([1..100],v->Concatenation([1..nn/2]*0,[1..nn/2]*0+1));

testvalues:=[1..nn*(nn-1)/2]*0; 

for i in [1..nn*(nn-1)/2] do a:=Random([1..nn*(nn-1)/2]); testvalues[a]:=testvalues[a]+1; a:=Random([1..nn*(nn-1)/2]); testvalues[a]:=testvalues[a]-1; od;

while true do 
for i in [1..100] do
new:=[];
a:=Random([1..10]);
b:=Random([1..10]);
for j in [1..nn] do
if Random([true,false]) then new[j]:=population[a][j]; else new[j]:=population[b][j]; fi;
od;
c:=Random([1..nn]); new[c]:=1-new[c];
Add(population,new);
od;

testvalues:=[1..nn*(nn-1)/2]*0; 
for i in [1..nn*(nn-1)/2] do a:=Random([1..nn*(nn-1)/2]); testvalues[a]:=testvalues[a]+1; a:=Random([1..nn*(nn-1)/2]); testvalues[a]:=testvalues[a]-1; od;

SortBy(population,v->pairscore(100,testvalues,bitstopairs(v)));

while Length(population)>10 do Remove(population); od;

#kk:=1000;
#Display(pairscore(kk,testvalues,bitstopairs(population[1]))^(1./kk));

axe:=[]; 
for i in [1..10] do
axe[i]:=[];
for j in [1..nn] do if population[i][j]=1 then axe[i][j]:='T'; else axe[i][j]:=' '; fi; od;
od;
Display(axe);
od;


normalform:=function(pair) local aa,output,bb,lar,kk,fix,nn,n,a,list,invlist; fix:=fixedpoints(pair); nn:=Length(pair); n:=LogInt(nn,2); a:=Random(fix); aa:=a[1]; list:=[]; invlist:=[]; for i in [1..nn] do lar:=map(n,i); bb:=aa; for kk in Reversed([1..n]) do bb:=pair[bb][lar[kk]+1]; od; list[i]:=bb; invlist[bb]:=i; od; output:=[]; for i in [1..nn] do output[i]:=[]; for j in [1..2] do output[i][j]:=invlist[pair[list[i]][j]]; od; od; return output; end;
